---
title: "fit_single"
output:
  html_document:
    df_print: paged
---

```{r source, message=FALSE, warning=FALSE}
setwd(dirname(getwd()))
source('paths.R', encoding="utf8")
source( file.path(post.dir, 'posterior.R'), encoding="utf8")
source( file.path(dataprep.dir, 'dataprep.R'), encoding="utf8")
memory.limit(48000)
library(cmdstanr)
```

data:

N : int, number of languages
feats_lang : data.frame, feats of languages for current family
trees.C : list, covariance matrices for language trees

features:

- NA : noun adjective order
    0: noun-adjective, 1:adjective-noun, -: other
  rename to AN, to avoid naming conflict
    
- PN : adposition noun order
    0: prepositions, 1: adpositions, -: other
    
- ND : noun demonstrative order
    0: noun-demonstrative, 1: demonstrative-noun, -: other

- NG : noun genetive order
    0: noun-genetive, 1: genetive-noun, -: other

- NNum : noun numeral order
    0: noun-numeral, 1: numeral-noun, -: other

- VO : verb object order
    0: verb-object, 1:object-verb, -: other

- NRc : noun relative clause order
    0: noun-relative clause, 1: relative clause-noun, -: other

- VS : verb subject order
    0: verb-subject, 1: subject-verb, -: other
-> after data preparation:
  - : 1; 0 : 2; 1 : 3


```{r prep feats}
lang.1 <- "Tai-Kadai"
lang.2 <- "Tai-Kadai"
trait.name.1 <- "AN"
trait.name.2 <- "PN"
trait.name.3 <- "ND"
trait.name.4 <- "NG"
trait.name.5 <- "NNum"
trait.name.6 <- "VO"
trait.name.7 <- "NRc"
trait.name.8 <- "VS"
trait.names <- c( trait.name.1, trait.name.2, 
                 trait.name.3, trait.name.4, 
                 trait.name.5, trait.name.6, 
                 trait.name.7, trait.name.8)
max.C <- 100

dats <- get.data( lang.1, c(trait.name.4, trait.name.5), 
                  bin=TRUE, other=0,
                  corr=TRUE, corFunc=ape::corBrownian, corParam=0.01 )
traits.2 <- get.data( lang.1, c(trait.name.4, trait.name.5), 
                  bin=TRUE, other=0,
                  corr=TRUE, corFunc=ape::corBrownian, corParam=1 )$traits
N <- dats$N
r <- dats$r
traits <- dats$traits

t.pairs <- c()
for (n in 1:N) {
  t.pairs[n] <- 1 + traits[n] + 2 * traits.2[N+n]
}

Cs <- dats$C
nMat <- dats$nMat
if ( length(Cs)>1 & max.C<nMat ) {
  set.seed(1)
  Cs <- sample( Cs, max.C )
  nMat <- max.C
  set.seed(NULL)
}
```
```{r set TwoTraitModel}
# Design Matrix
dMat <- matrix(0, nrow=N*2, ncol=2)
for (i in 1:(N*2)) {
  for (j in 1:2) {
    if ( (j-1*N < i)&(i<=j*N) ){
      dMat[i,j] <- 1
    }
  }
}

dat <- list(
  N = N,
  x = traits,
  M = nMat,
  C = Cs,
  dMat = designMatrix(N, 2),
  # Hyperparameters
  eta = 1,
  lambda = 1,
  mu_z = 0,
  sigma_z = 1.5,
  mu_alpha = 0,
  sigma_alpha = 1,
  mu_beta = 0,
  sigma_beta = 1
)

options(mc.cores = parallel::detectCores())
chains <- 4

model <- cmdstanr::cmdstan_model( 
  file.path( models.dir, 'categorical', 'TwoTraits-binom-multiC-cholesky-nonCentered-main.stan' ) )
model$check_syntax(pedantic=TRUE)
print(dat$x)
```
```{r fit}
fit <- model$sample(
  data=dat, chains=chains, parallel_chains=chains, iter_sampling=4000, iter_warmup=4000,
  refresh=800, save_warmup=TRUE,
  max_treedepth=10, adapt_delta=0.8
)
beepr::beep(2)
```

## cmdstanr diagnostics

```{r sampler diagnostics, paged.print=FALSE}
fit$cmdstan_diagnose()
```

```{r summary, paged.print=FALSE}
corr = "sigma_sq"
fit$summary(variables=c("z", corr, "p"))
```

```{r posterior histograms, message=FALSE, paged.print=FALSE}
bayesplot::mcmc_hist( fit$draws("z") )
bayesplot::mcmc_hist( fit$draws("exp_z") )
bayesplot::mcmc_hist( exp( fit$draws("z") ) )
bayesplot::mcmc_hist( fit$draws("alpha") )
bayesplot::mcmc_hist( fit$draws("soft_a") )
bayesplot::mcmc_hist( fit$draws(corr) )
bayesplot::mcmc_hist( exp( fit$draws(corr) ) )
plots <- list()
i <- 1 
for (n in 1:N) {
  ps <- sapply(X=(rep(1:4)), FUN=function(x) paste("p[1,", n, ",", x, "]", sep=""))
  plots[[i]] <- bayesplot::mcmc_hist((fit$draws( variables=ps )))
  i <- i+1
}
browns <- sapply(X=(rep(1:N)), FUN=function(n) paste("brown[1,", n, "]", sep=""))
plots[[i]] <- bayesplot::mcmc_hist(( fit$draws( variables=browns )) )
plots
beepr::beep(1)
```

## posterior plot

```{r plot R}
#plot.multiR(fit, dat$M)
```

## stanfit diagnostics

```{r make stanfit}
stanfit <- rstan::read_stan_csv(fit$output_files())
```

```{r parameters}
print(stanfit, pars=c(corr, "z", "alpha"))
#rstan::plot(stanfit, pars=c(corr, "p", "not_center"))
```

```{r pairs, fig.width=8}
pairs(stanfit, pars=c(corr, "not_center", "lp__"))
```

```{r chain traces(a, mu, R)}
plots <- list()
i <- 1 
for (n in 1:N) {
  ps <- sapply(X=(rep(1:4)), FUN=function(x) paste("p[1,", n, ",", x, "]", sep=""))
  plots[[i]] <- rstan::traceplot(stanfit, pars=c( ps ), inc_warmup=TRUE)
  i <- i+1
}
plots
rstan::traceplot(stanfit, pars=c( corr ), inc_warmup=TRUE)
rstan::traceplot(stanfit, pars=c( "alpha" ), inc_warmup=TRUE)
```

```{r loo}
fit.log_lik <- loo::extract_log_lik(stanfit, merge_chains=FALSE)
r_eff <- loo::relative_eff(exp(fit.log_lik), cores = 4)
fit.loo <- loo::loo(fit.log_lik, r_eff=r_eff, cores = 4)
print(fit.loo)
rm(fit.loo)
```

```{r dWaic, paged.print=FALSE}
library(rethinking)
rethinking::WAIC(stanfit)
```

```{r finished}
beepr::beep(8)
```











