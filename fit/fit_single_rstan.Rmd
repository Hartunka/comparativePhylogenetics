---
title: "fit_single"
output:
  html_document:
    df_print: paged
---

```{r source, message=FALSE, warning=FALSE}
source('libraries.R', encoding="utf8")
source('paths.R', encoding="utf8")
source('dataprep_foo.R', encoding="utf8")
```

data:

N : int, number of languages
feats_lang : data.frame, feats of languages for current family
trees.C : list, covariance matrices for language trees

features:

- NA : noun adjective order
    0: noun-adjective, 1:adjective-noun, -: other
  rename to AN, to avoid naming conflict
    
- PN : adposition noun order
    0: prepositions, 1: adpositions, -: other
    
- ND : noun demonstrative order
    0: noun-demonstrative, 1: demonstrative-noun, -: other

- NG : noun genetive order
    0: noun-genetive, 1: genetive-noun, -: other

- NNum : noun numeral order
    0: noun-numeral, 1: numeral-noun, -: other

- VO : verb object order
    0: verb-object, 1:object-verb, -: other

- NRc : noun relative clause order
    0: noun-relative clause, 1: relative clause-noun, -: other

- VS : verb subject order
    0: verb-subject, 1: subject-verb, -: other
-> after data preparation:
  - : 1; 0 : 2; 1 : 3


'Problematic' pairs:
AN - ND,
AN - VO,
ND - VO
-> Healthy Chains with independence assumption
```{r prep feats}
lang <- "Dravidian"
trait.name.1 <- "AN"
trait.name.2 <- "PN"
feats <- read.feats(lang)
feats.bin <- read.feats(lang, bin=TRUE)

lang.names <- as.character( feats$X )
trees.C.lang <- read.trees(lang, lang.names)

N <- length(rownames(trees.C.lang[[1]]))

# reorder matrices to fit feature order
lang.names <- as.character( feats[feats$glot == lang,]$X )
for ( i in 1:length(trees.C.lang) ) {
  trees.C.lang[[i]] <- trees.C.lang[[i]][lang.names, lang.names]
}

#trait.1 <- as.integer( unlist(feats[feats$glot == lang,][trait.name.1]) )
#trait.2 <- as.integer( unlist(feats[feats$glot == lang,][trait.name.2]) )
trait.1 <- as.integer( unlist(feats[trait.name.1]) )
trait.2 <- as.integer( unlist(feats[trait.name.2]) )

#trait.1.bin <- as.integer( unlist(feats.bin[trait.name.1]) )
#trait.2.bin <- as.integer( unlist(feats.bin[trait.name.2]) )
```
```{r TwoTraitModel}
# Design Matrix
dMat <- matrix(0, nrow=N*2, ncol=2)
for (i in 1:(N*2)) {
  for (j in 1:2) {
    if ( (j-1*N < i)&(i<=j*N) ){
      dMat[i,j] <- 1
    }
  }
}
#dMat <- matrix(0, nrow=N, ncol=2)
#for (i in 1:(N)) {
#  for (j in 1:2) {
#    if ( (j-1*(N/2) < i)&(i<=j*(N/2)) ){
#      dMat[i,j] <- 1
#    }
#  }
#}

dat <- list(
  N = N,
  x = c( trait.1, 
         trait.2 ),
  nMat = length(trees.C.lang),
  C = trees.C.lang,
  dMat = dMat,
  # Hyperparameters
  eta = 0.8,
  mu_z = 0,
  sigma_z = 0.5,
  mu_a = 0,
  sigma_a = 0.5,
  mu_b = 1,
  sigma_b = 0.5
)

options(mc.cores = parallel::detectCores())
# memory.limit( size=40000 )
chains = 4
model = paste( models_path, 'TwoTraits-multinom-multiC.stan', sep="")
fit <- stan(
  file=model, 
  data=dat, cores=chains, chains=chains, iter=8000, 
  control=list(adapt_delta=0.8, max_treedepth=10)
)
beepr::beep(2)
```

## diagnostics

```{r parameters}
corr = "R"

print(fit, pars=c("a", corr, "mu"))
plot(fit, pars=c("a", corr, "mu"))
```

```{r pairs, fig.width=12}
pairs(fit, pars=c("a", corr, "mu"))
```

```{r chain traces(a, mu, R)}
rstan::traceplot(fit, pars=c( "a" ), inc_warmup=TRUE)
rstan::traceplot(fit, pars=c( "b" ), inc_warmup=TRUE)
rstan::traceplot(fit, pars=c( "mu" ), inc_warmup=TRUE)
rstan::traceplot(fit, pars=c( corr ), inc_warmup=TRUE)
```

```{#r chain ranks(a, mu, R)}
trankplot(fit, pars=c( "a", "sigma_sq" ))
trankplot(fit, pars=c( "mu" ))
# trankplot(fit, pars=c( "R[1,2]", "R[2,1]", "R[2,2]"  ))
# trankplot(fit, pars=c( "R_h[1,2]", "R_h[2,1]", "R_h[2,2]"  ))
```

```{r loo}
fit.log_lik <- extract_log_lik(fit, merge_chains=FALSE)
r_eff <- relative_eff(exp(fit.log_lik), cores = 4)
fit.loo <- loo(fit.log_lik, r_eff=r_eff, cores = 4)
print(fit.loo)
```

```{r dWaic, paged.print=FALSE}
rethinking::WAIC(fit)
rethinking::PSIS(fit)
```

```{r finished}
beepr::beep(8)
```




